---
title: 'CommonJS规范'
date: '2022-08-30 16:37'
tags: ['ES6', 'Web', 'CommonJS']
draft: false
layout: PostLayout
summary: 'CommonJS规范'
---

文章内容来自于[阮一峰老师博客](https://javascript.ruanyifeng.com/nodejs/module.html#toc6),其他详情请拜读原文。

#### 概述

- 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。
- 如果想在多个文件分享变量，必须定义为global对象的属性。
  ```js
  global.warning = true
  ```
- 所有代码都运行在模块作用域，不会污染全局作用域。
- 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
- 模块加载的顺序，按照其在代码中出现的顺序。

#### module对象

　　如果在命令行下调用某个模块，比如node something.js，那么module.parent就是null。
　　如果是在脚本之中调用，比如require('./something.js')，那么module.parent就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。

```node
if (!module.parent) {
  // ran with `node something.js`
  app.listen(8088, function () {
    console.log('app listening on port 8088')
  })
} else {
  // used with `require('/.something.js')`
  module.exports = app
}
```

每个模块内部，都有一个module对象，代表当前模块。它有以下属性。

- module.id 模块的识别符，通常是带有绝对路径的模块文件名。
- module.filename 模块的文件名，带有绝对路径。
- module.loaded 返回一个布尔值，表示模块是否已经完成加载。
- module.parent 返回一个对象，表示调用该模块的模块。
- module.children 返回一个数组，表示该模块要用到的其他模块。
- module.exports 表示模块对外输出的值。

#### module.exports属性

module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。
如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。

#### require命令

require命令用于加载文件，后缀名默认为.js。

- 根据参数的不同格式，require命令去不同路径寻找模块文件。
  1. 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require('/home/marco/foo.js')将加载/home/marco/foo.js。
  2. 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require('./circle')将加载当前脚本同一目录的circle.js。
  3. 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。
  4. 如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require('example-module/path/to/file')，则将先找到example-module的位置，然后再以它为参数，找到后续路径。
  5. 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。
  6. 如果想得到require命令加载的确切文件名，使用require.resolve()方法。

#### 模块的缓存

第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性。
所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写。

```node
// 删除指定模块的缓存
delete require.cache[moduleName]

// 删除所有模块的缓存
Object.keys(require.cache).forEach(function (key) {
  delete require.cache[key]
})
```

#### 模块的加载机制

CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。

#### CommonJS与ES6区别

- CommonJS模块输出的是一个值的复制 ES6模块输出的是值的引用
- CommonJS模块是运行时加载，ES6模块是编译时输出接口

```JS
// CommonJS
module.exports = {
  foo:"hello",
  bar:"world"
}
// 等同于
exports.default = {
  foo:"hello",
  bar:"world"
}


exports.foo = 'hello'
```

```JS
// ES6
export default {
  foo:"hello",
  bar:"world"
}

export let foo = 'heool'
```
