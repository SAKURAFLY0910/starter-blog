---
title: '12. SQLServer : 控制流'
date: '2022-11-11 14:30'
tags: ['SQLServer', 'Database']
draft: false
summary: '控制流是用于管理T-SQL脚本执行流程的逻辑结构，主要包括条件分支（IF-ELSE）、循环（WHILE）、异常处理（TRY-CATCH）等。它使开发者能够实现复杂的业务逻辑，如根据条件执行不同操作（IF）、重复处理数据（WHILE）或捕获运行时错误（TRY-CATCH）。'
layout: PostLayout
---

<TOCInline toc={props.toc} />

### BEGIN...END

```SQL
-- BEGIN 和 END 定义一系列一起执行的 Transact-SQL 语句。 如果不包括 BEGIN...END 块，则将执行两个 ROLLBACK TRANSACTION 语句，并返回两条 PRINT 消息

USE AdventureWorks2012
GO
BEGIN TRANSACTION
GO
IF @@TRANCOUNT = 0
BEGIN
    SELECT FirstName, MiddleName
    FROM Person.Person WHERE LastName = 'Adams';
    ROLLBACK TRANSACTION;
    PRINT N'Rolling back the transaction two times would cause an error.';
END;
ROLLBACK TRANSACTION;
PRINT N'Rolled back the transaction.';
GO
/*
Rolled back the transaction.
*/
```

### BREAK

BREAK 将退出当前 WHILE 循环。 如果当前循环嵌套在另一个循环中，BREAK 将只退出当前循环，并且将控制给予外部循环中的下一个语句。

BREAK 通常位于 IF 语句中。

```SQL
WHILE (1=1)
BEGIN
   IF EXISTS (SELECT * FROM ##MyTempTable WHERE EventCode = 'Done')
   BEGIN
      BREAK;  -- 'Done' row has finally been inserted and detected, so end this loop.
   END

   PRINT N'The other process is not yet done.';  -- Re-confirm the non-done status to the console.
   WAITFOR DELAY '00:01:30';  -- Sleep for 90 seconds.
END
```

### CONTINUE

重新开始 WHILE 循环。 在 CONTINUE 关键字之后的任何语句都将被忽略。 CONTINUE 通常由一个 IF 测试打开，但并不始终这样。

```SQL
DECLARE @m INT =1
WHILE (@m <= 10)
BEGIN
  PRINT N'开始:'+ cast(@m as nvarchar(255))
   IF @m = 3
    BEGIN
	 Set @m+=2
	 continue;
	END
   ELSE
   BEGIN
    Set @m+=1
   END
  PRINT '@m:'+ cast(@m as nvarchar(255))
END
select @m
```

### IF...ELSE

```SQL
DECLARE @Number INT;
SET @Number = 50;
IF @Number > 100
   PRINT 'The number is large.';
ELSE
   BEGIN
      IF @Number < 10
      PRINT 'The number is small.';
   ELSE
      PRINT 'The number is medium.';
   END ;
GO
```

### GOTO

将执行流更改到标签处。 跳过 GOTO 后面的 Transact-SQL 语句，并从标签位置继续处理。 GOTO 语句和标签可在过程、批处理或语句块中的任何位置使用。 GOTO 语句可嵌套使用。

```SQL
DECLARE @Counter int;
SET @Counter = 1;
WHILE @Counter < 10
BEGIN
    SELECT @Counter
    SET @Counter = @Counter + 1
    IF @Counter = 4 GOTO Branch_One --Jumps to the first branch.
    IF @Counter = 5 GOTO Branch_Two  --This will never execute.
END
Branch_One:
    SELECT 'Jumping To Branch One.'
    GOTO Branch_Three; --This will prevent Branch_Two from executing.
Branch_Two:
    SELECT 'Jumping To Branch Two.'
Branch_Three:
    SELECT 'Jumping To Branch Three.';
```

### RETURN

从查询或过程中无条件退出。 RETURN 的执行是即时且完全的，可在任何时候用于从过程、批处理或语句块中退出。 RETURN 之后的语句是不执行的。

```SQL
CREATE PROCEDURE findjobs @nm sysname = NULL
AS
IF @nm IS NULL
    BEGIN
        PRINT 'You must give a user name'
        RETURN  -- 之后的代码不会再执行
    END
ELSE
    BEGIN
        SELECT o.name, o.id, o.uid
        FROM sysobjects o INNER JOIN master..syslogins l
            ON o.uid = l.sid
        WHERE l.name = @nm
    END;
```

### THROW

```SQL
-- 语法
THROW [ { error_number | @local_variable },   -- 状态
        { message | @local_variable },   -- 错误信息
        { state | @local_variable } ]   -- 状态码 0 - 255
[ ; ]

-- 示例
THROW 51000, 'The record does not exist.', 6;
```

### TRY...CATCH

如果 TRY 块内部发生错误，则会将控制传递给 CATCH 块中包含的另一个语句组。

```SQL
-- 语法
BEGIN TRY
     { sql_statement | statement_block }
END TRY
BEGIN CATCH
     [ { sql_statement | statement_block } ]
END CATCH
[ ; ]



-- 示例
BEGIN TRY
    -- Generate a divide-by-zero error.
    SELECT 1/0;
END TRY
BEGIN CATCH
    SELECT
        ERROR_NUMBER() AS ErrorNumber
        ,ERROR_SEVERITY() AS ErrorSeverity
        ,ERROR_STATE() AS ErrorState
        ,ERROR_PROCEDURE() AS ErrorProcedure
        ,ERROR_LINE() AS ErrorLine
        ,ERROR_MESSAGE() AS ErrorMessage;
END CATCH;
GO
```

### WAITFOR

阻止执行批处理、存储过程或事务，直到已过指定时间或时间间隔，或者指定语句发生修改或至少返回一行为止。

```SQL
-- 语法
WAITFOR
{
    DELAY 'time_to_pass'
  | TIME 'time_to_execute'
  | [ ( receive_statement ) | ( get_conversation_group_statement ) ]
    [ , TIMEOUT timeout ]
}

```

#### WAITFOR TIME : 当时间某一刻时执行语句

```SQL
-- 在晚上 10:20 (22:20) 在 msdb 数据库中执行 sp_update_job 存储过程
EXECUTE sp_add_job @job_name = 'TestJob';
BEGIN
    WAITFOR TIME '22:20';
    EXECUTE sp_update_job @job_name = 'TestJob',
        @new_name = 'UpdatedJob';
END;
GO
```

```SQL
-- 只能是[时间]格式
BEGIN
  WAITFOR TIME '15:29:40'
  SELECT getdate()
END
```

#### WAITFOR DELAY : 延迟指定时间之后运行语句

```SQL
-- 在两小时的延迟后执行存储过程
BEGIN
    WAITFOR DELAY '02:00';
    BEGIN
      EXECUTE sp_helpdb;
    END
END;
GO
```

### WHILE

设置重复执行 SQL 语句或语句块的条件。 只要指定的条件为真，就重复执行语句。 可以使用 BREAK 和 CONTINUE 关键字在循环内部控制 WHILE 循环中语句的执行。

```SQL
USE AdventureWorks2012;
GO
WHILE (SELECT AVG(ListPrice) FROM Production.Product) < $300
BEGIN
   UPDATE Production.Product
      SET ListPrice = ListPrice * 2
   SELECT MAX(ListPrice) FROM Production.Product
   IF (SELECT MAX(ListPrice) FROM Production.Product) > $500
      BREAK
   ELSE
      CONTINUE
END
PRINT 'Too much for the market to bear';
```
